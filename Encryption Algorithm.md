# **Enigmatrix Encryption Algorithm: Core Functionality & Design**

## **Introduction**
Enigmatrix is a **high-security encryption algorithm** designed for large-scale data protection. It operates on **1024×1024 matrices**, utilizing **hash-based key expansion, cryptographic permutations, modular arithmetic operations, and PRNG-driven obfuscation** to ensure robust security. This document details the core functionalities, optional features, and design rationale of Enigmatrix.

---

## **1. Key Expansion Mechanism**
Key expansion is a critical step that generates subkeys used for encryption and decryption. Enigmatrix employs a **multi-stage deterministic expansion process** to derive large subkey matrices from a relatively smaller raw key.

### **1.1 Raw Key Handling**
- The user provides a **raw key** (must be at least **6 characters long**, no upper limit).
- The raw key is **instantly hashed**, producing a **Primary Hash (PH)**.
- **PH and the raw key are iteratively mixed with later subkeys** to create further keys, ensuring **avalanche effect and diffusion**.

### **1.2 Primary Hash Computation (PH)**
- A cryptographic hash is computed over the **entire raw key**.
- This hash (PH) is further processed to extract **two PRNG seeds**.

### **1.3 PRNG Seed Generation**
- The **primary hash (PH) is split into four 128-bit sections**.
- Two PRNG seeds are generated by **XORing overlapping sections**:
  - **Seed 1 = (PH1 ⊕ PH2) ⊕ PH3**
  - **Seed 2 = (PH2 ⊕ PH3) ⊕ PH4**

### **1.4 Subkey Matrix Generation**
For each encryption round:
1. **Concatenate** PH and previously generated subkeys.
2. **Apply alternating cryptographic hash functions**:
   - **SHA-256 for even rounds**.
   - **BLAKE2b for odd rounds**.
3. **Feedback loop-based expansion**:
   - The hash output is repeatedly expanded to fill a **1024×1024 subkey matrix**.
   - If needed, the expansion loops until the entire matrix is filled.

---

## **2. Encryption Process**
Once the subkey matrix is generated, Enigmatrix performs **multi-stage transformations** on the data matrix.

> **The following are the operations performed on each 1MB chunk matrix, in a random order determined by PRNG**

### **2.1 XOR Operation**
- All the chunks of 1MB matrices and subkey matrices of equal dimension are simply XOR'ed

### **2.2 Modular Arithmetic Operations**
- The subkey matrix is applied to the data matrix using **modular addition and subtraction**.
- The **order of operations (addition first or subtraction first) is PRNG-determined**.
- In second round, the **sub-key matrix is transposed and addition/subtraction operation is carried out** to introduce diffusion.
- **Seeds are used to generate deterministic values while maintaining randomness** in operation sequences.


### **2.3 PRNG-Driven Row/Column Swaps**
- A minimum of **512 row/column swaps** per 1MB ensures strong diffusion.
- **Seed 2** determines:
  - Whether **row permutation or column permutation** is applied first.
  - Which **rows/columns** to swap.
  - The **sequence of operations**.
- The use of PRNG ensures that **swap operations are deterministic yet randomized**, adding complexity to encryption.

---

## **3. Decryption Process**
> **To obtain the original data, these operations are again performed in order determined by PRNG**

The decryption process follows the **reverse sequence** of encryption:
1. **XOR the chunk matrices using sub-key matrices**.
2. **Reverse modular arithmetic operations** (subtract if addition was applied first, and vice versa).
3. **Apply inverse permutation using stored swap order.**

---

## **4. Optional Features**

### **4.1 RSA-Encrypted Key Handling** 
- If enabled, the raw key is **encrypted with RSA** before key expansion.
- The encrypted key is stored in the file header.
- The recipient decrypts the key using their **RSA private key** before encryption begins.

### **4.2 UI Customization Options**
- Enigmatrix allows users to enable a **retro green terminal look**.
- The **left panel** of the UI is a retro terminal, while the **right panel** is a graphical interface.
- Users can enter a specific **command to switch to a full retro terminal mode**, hiding the GUI.
- The GUI can be brought back using another **command**.

---

## **5. Algorithm Design Rationale**
- **1024×1024 matrices ensure computational efficiency** while maintaining high security.
- **Alternating hash algorithms prevent predictable key expansion patterns**.
- **PRNG-controlled permutations and operations introduce dynamic unpredictability**.
- **Modular arithmetic operations ensure strong diffusion**.
- **Optional RSA integration makes key management more secure**.
